# Основы ООП

**Напоминание**: звёздочками выделено то, что будет на защите и экзамене.

Все примеры кода написаны на Java, но эти принципы являются общими для всех объектно-ориентированных языков программирования.

## Что такое ООП? *

Объектно ориентированное программирование (ООП) - это парадигма программирования, которая берёт за основу программы классы, объекты и их взаимодействие.

ООП облегчает работу с большими проектами, разбивая программу на более мелкие независимые сущности, которые легче понимать: объекты схожи с реальным миром, они содержат в себе состояние, инкапсулируют логику.

## Классы *

Классы - это шаблоны для объектов. Они описывают, какие функции (методы) и свойства (поля) будут иметь экземпляры (объекты) этого класса. При создании этих объектов каждый из них будет иметь собственные поля и методы, независимые от других объектов.

Напишем класс компьютера и создадим пару экземпляров:

```java
class Computer { // класс компьютера
  public int cores; // поле, хранящее значение типа int32

  public int getCores() { // метод, возвращающий значение cores - количество ядер
    return cores;
  }
}

public class Main { // основной класс программы
  public static void main(String[] args) { // стартовая точка программы
    Computer computer1 = new Computer(); // создаём первый объект
    Computer computer2 = new Computer(); // создаём второй объект

    computer1.cores = 4; // задаём количество ядер первому компьютеру
    computer2.cores = 2; // задаём количество ядер второму компьютеру
  }
}
```

Получаем два назависимых объекта, каждый из которых хранит своё значение переменной cores. То есть у них обоих она есть, но значение - разное.

Обратите внимание, как мы создаёт эти объекты: мы используем ключевое слово `new`, которое вызывает **конструктор** - специальный статический метод, который создаёт новый экземпляр этого класса.

### Статические методы и поля *

Существуют также статические поля и методы, которые не привязаны к конкретному объекту, а к самому классу, и доступ к ним нужно осуществлять уже из класса, а не объекта. Из этого следует, что поля будут в одном экземпляре на всю программу, так как класс всего один.

```java
public class Computer {
  public static String name = "Computer"; // статическое поле

  public static String getName() { // статический метод
    return name;
  }

  public int cores;

  public int getCores() {
    return cores;
  }
}

public class Main {
  public static void main(String[] args) { // тоже статический метод
    Computer computer1 = new Computer();
    Computer computer2 = new Computer();

    // попробуем вывести значение
    System.out.println(computer1.name); // работать не будет, у объектов нет этого поля, только у класса
    System.out.println(Computer.name); // сработает!
  }
}
```

## Инкапсуляция *

Инкапсуляция — это механизм, который объединяет данные и методы, работающие с этими данными, и скрывает детали реализации (того, как они написаны).

Инкапсуляция позволяет защитить данные от некорректного использования и обеспечить контроль над доступом к данным, что делает программу более надежной и безопасной.

## Наследование *

Наследование — это механизм, который позволяет одному классу наследовать свойства и методы другого класса.

Наследование позволяет создавать новые классы на основе существующих. Это делает код переиспользуемым - не надо писать одно и то же в разных местах - и помогает расширять функциональность.

```java
public class Computer {
  public int cores;

  public int getCores() {
    return cores;
  }
}

public class Macbook extends Computer { // класс Macbook наследует поля и методы класса Computer
}

public class Main {
  public static void main(String[] args) {
    Macbook macbook = new Macbook();
    macbook.cores = 4; // мы можем так сделать, так как класс Macbook унаследовал поле cores

    Computer computer = new Macbook(); // мы можем так сделать,
    // потому что класс Macbook наследуется от класса Computer
  }
}
```

## Наследование или композиция? *

Композиция — механизм, который позволяет одному классу содержать объекты других классов. Композиция используется для создания сложных объектов, состоящих из других объектов, и когда отношение "часть-целое" более подходящее, чем отношение "родитель-потомок" (наследование). Композиция делает программу более гибкой и позволяет избежать проблем, связанных с наследованием.

Больше информации о композиции и наследовании (не обязательно к изучению):

https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance

https://en.wikipedia.org/wiki/Composition_over_inheritance

https://blogs.oracle.com/javamagazine/post/java-inheritance-composition

## Полиморфизм *

Иногда появляется необходимость переопределить то, как работают методы класса-родителя (от которого наследуемся). Для этого приходит в помощь механизм… переопределения.

Приведём пример:

У макбука резко появились супер-дупер ядра, значение которых нужно возвращать вместо количества ядер обычных. Мы можем либо написать свой метод (getSuperDuperCores), либо убрать наследование от класса компьютер.

Второй вариант не подходит от слова совсем: как это макбук не компьютер? (но бывают и другие причины. Например, помимо метода getCores есть ещё 100 методов, которые не хотелось бы копировать).

Посмотрим, что не так с первым:

```java
public class Computer {
  public int cores;

  public int getCores() {
    return cores;
  }
}

public class Macbook extends Computer {
  public int superDuperCores;

  public int getSuperDuperCores() {
    return superDuperCores;
  }
}

public class Main {
  public static void main(String[] args) {
    Macbook macbook = new Macbook();
    macbook.cores = 4;
    macbook.superDuperCores = 32;
    System.out.println(getCoresHalfed(macbook)); // мы получим в выводе не 16, а 2!
  }

  public static int getCoresHalfed(Computer computer) {
    return computer.getCores() / 2;
  }
}
```

Почему мы получим не 16, а 2?

Потому что метод getCoresHalfed использует класс Computer, и даже если мы очень захотим, в этом методе не получится использовать метод getSuperDuperCores, так как мы работаем с объектом типа Computer, у которого он просто не определён.

В таких ситуациях спасает переопределение:

```java
public class Computer {
  public int cores;

  public int getCores() {
    return cores;
  }
}

public class Macbook extends Computer {
  public int superDuperCores;

  @Override
  public int getCores() {
    return superDuperCores;
  }
}

public class Main {
  public static void main(String[] args) {
    Macbook macbook = new Macbook();
    macbook.cores = 4;
    macbook.superDuperCores = 32;
    System.out.println(getCoresHalfed(macbook)); // теперь всё будет ОК! получим 16
  }

  public static int getCoresHalfed(Computer computer) {
    return computer.getCores() / 2;
  }
}
```

Когда несколько классов переопределяют метод родителя по-своему, но при этом мы работаем с ними как будто они являются экземплярами родительского класса называется **полиморфизмом**

## Абстрактные классы *

Бывают ситуации, когда мы точно не можем сказать, что должен будет делать метод:

```java
public class Shape {
  public double getArea() {
    return 0.0; // мы точно не знаем, что надо здесь возвращать: это зависит от наследника
  }
}

public class Circle extends Shape {
  public double radius;
  // даже если мы не переопределим метод getArea, программа сработает и не будет выдавать ошибки
}

public class Main {
  public static void main(String[] args) {
    Circle circle = new Circle();
    circle.radius = 10.0;
    System.out.println(circle.getArea()); // получим 0!
  }
}
```

Это может показаться глупостью: можно ведь просто переопределить метод, но если проект большой, классов и методов много, такое легко упустить из виду. В таком случае помогут абстрактные классы: это классы, часть реализации которых не надо сразу задавать, только описывать **сигнатуру** методов (что они принимают, как называются и что возвращают):

```java
public abstract class Shape {
  public abstract double getArea(); // сигнатура метода getArea
}

public class Circle extends Shape {
  public double radius;

  @Override
  public double getArea() { // теперь мы обязаны переопределить этот метод: иначе будет ошибка компиляции
    return Math.PI * radius * radius;
  }
}

public class Main {
  public static void main(String[] args) {
    Circle circle = new Circle();
    circle.radius = 10.0;
    System.out.println(circle.getArea()); // получим 314 с копейками
  }
}
```

Теперь всё работает!

## Интерфейсы *

Предположим, что мы ничего не можем сказать о реализации какого-то класса:

```java
public abstract class DatabaseConnection {
  public abstract boolean connect();

  public abstract boolean disconnect();

  public abstract String request(String query);
}
```

Мы не можем дать определение этим методам, потому что мы не знаем наверняка, какая база данных у нас будет, какие протоколы будут использоваться для соединения и т.д.

По сути, мы как раз и написали интерфейс: абстрактный класс, где все методы являются публичными и абстрактными.

Работая с интерфейсами вместо конкретных классов, мы повышаем уровень абстрактности в нашем проекте, не завязываемся на их реализации. Это позволяет, например, в любой момент поменять реализацию интерфейса, не поломав ничего в нашей программе.

## SOLID *

SOLID - аббревиатура нескольких принципов, позволяющих писать чистый поддерживаемый код.

S - Single responsibility principle или же принцип единой ответственности, который гласит:

Каждая программная сущность должна выполнять одну функцию. Это помогает упростить код, его понимание и написание: легче правильно написать и понять один метод в классе, чем 100.

O - Open-close principle принцип открытости-закрытости. Он гласит: программные сущности должны быть открыты для расширения и закрыты для изменения. Это означает, что классы, например, нельзя изменять с точки зрения их интерфейсов, только добавлять новые методы. Благодаря этому можно гарантировать обратную совместимость с уже написанным кодом: мы могли бы удалить метод, который используется где-то ещё, и это всё нам поломает.

L - Liskov substitution principle принци подстановки Лисков:

Если у нас есть класс A (не виртуальный, а вполне реально используемый в  коде) и отнаследованный от него класс B, то если мы заменим все  использования класса A на B, ничего не должно измениться в работе  программы (взял из: https://habr.com/ru/articles/83269, очень советую почитать, если не поняли).

I - Interface segregation principle принцип сергрегации интерфейсов:

Программные сущности не должны зависеть от методов, которые они не используют. То есть надо разделять больние интерфейсы на более малые, и реализовывать в классах только то методы, которые правда нужны и используются.

D - Dependency inversion principle принцип инверсии зависимостей:

Его формулировка - зависимости должны быть основаны на абстракциях, а не на конкретных реализациях. Это означает, что

Очень хорошая статья про этот принцип (не обязательно, но рекомендую прочитать): https://habr.com/ru/articles/313796/
